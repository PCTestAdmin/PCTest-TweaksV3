# -----------------------------
# Kombiniertes Netzwerk-, FPS-, RAM- und Software-Optimierungs-Skript
# -----------------------------

	# Starte das Skript mit Administratorrechten
	if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) {
    Write-Host "Bitte PowerShell als Administrator ausf√ºhren!"
    Start-Sleep -Seconds 3
    exit
	}




function Show-HardwareInfo {
    Clear-Host
    # Logo
    Write-Host "`n$asciiLogo" -ForegroundColor Magenta

    # Sammle Basis-Infos
    $osObj = Get-CimInstance Win32_OperatingSystem | Select-Object -First 1 Caption, Version, LastBootUpTime, OSArchitecture
    $os = "$($osObj.Caption) (v$($osObj.Version))"
    $uptime = ((Get-Date) - $osObj.LastBootUpTime).ToString("dd\.hh\:mm\:ss")

    $cpuObj = Get-CimInstance Win32_Processor | Select-Object -First 1 Name, NumberOfCores, NumberOfLogicalProcessors, MaxClockSpeed, Architecture
    $cpuCores = $cpuObj.NumberOfCores
    $cpuThreads = $cpuObj.NumberOfLogicalProcessors
    $cpuSpeed = $cpuObj.MaxClockSpeed
    $archMap = @{0='x86'; 1='MIPS'; 2='Alpha'; 3='PowerPC'; 5='ARM'; 6='Itanium-based'; 9='x64'}
    if ($archMap.ContainsKey($cpuObj.Architecture)) {
        $cpuArch = $archMap[$cpuObj.Architecture]
    } else {
        $cpuArch = $cpuObj.Architecture.ToString()
    }

    $gpuObj = Get-CimInstance Win32_VideoController | Select-Object -First 1 Name, @{n='VRAM_GB';e={[math]::Round($_.AdapterRAM/1GB,2)}}
    $gpuVRAM = $gpuObj.VRAM_GB

    $csObj = Get-CimInstance Win32_ComputerSystem | Select-Object Manufacturer, Model, Domain
    # Precompute Domain
    if ($csObj.Domain) { $domainValue = $csObj.Domain } else { $domainValue = 'Workgroup' }

    # BIOS Release
    $biosObj = Get-CimInstance Win32_BIOS | Select-Object -First 1 Manufacturer, SMBIOSBIOSVersion, ReleaseDate
    try {
        $biosDate = [Management.ManagementDateTimeConverter]::ToDateTime($biosObj.ReleaseDate).ToString('yyyy-MM-dd')
    } catch {
        $biosDate = 'Unknown'
    }

    $ramModules = Get-CimInstance Win32_PhysicalMemory | Select-Object Manufacturer, Speed, @{n='SizeGB';e={[math]::Round($_.Capacity/1GB)}}
    $ramTotal = ($ramModules | Measure-Object SizeGB -Sum).Sum

    $diskC = Get-CimInstance Win32_LogicalDisk -Filter "DeviceID='C:'" | Select-Object -First 1 @{n='FreeGB';e={[math]::Round($_.FreeSpace/1GB,2)}}, @{n='SizeGB';e={[math]::Round($_.Size/1GB,2)}}

    $netAdapter = Get-NetAdapter | Where-Object Status -eq 'Up' | Select-Object -First 1
    $ipObj = Get-NetIPAddress -InterfaceIndex $netAdapter.InterfaceIndex -AddressFamily IPv4 | Select-Object -First 1 IPAddress
    $mac = $netAdapter.MacAddress

    # Aktuellen Energieplan erkennen
    $guidLine = (powercfg /GetActiveScheme) 2>&1
    if ($guidLine -match '\((.+)\)') { $planName = $Matches[1] } else { $planName = 'Unknown' }

    $entries = @(
        @{Label='OS'; Value=$os},
        @{Label='Arch'; Value=$osObj.OSArchitecture},
        @{Label='Uptime'; Value=$uptime},
        @{Label='CPU'; Value="$cpuCores cores, $cpuThreads threads @ ${cpuSpeed}MHz"},
        @{Label='CPU Arch'; Value=$cpuArch},
        @{Label='GPU'; Value="$($gpuObj.Name) ($gpuVRAM GB VRAM)"},
        @{Label='Motherboard'; Value="$($csObj.Manufacturer) $($csObj.Model)"},
        @{Label='Domain'; Value=$domainValue},
        @{Label='BIOS'; Value="$($biosObj.Manufacturer) $($biosObj.SMBIOSBIOSVersion) ($biosDate)"},
        @{Label='RAM Total'; Value="$ramTotal GB"},
        @{Label='Disk C:'; Value="Free: $($diskC.FreeGB) GB / $($diskC.SizeGB) GB"},
        @{Label='IP Addr'; Value=$ipObj.IPAddress},
        @{Label='MAC Addr'; Value=$mac},
        @{Label='Power Plan'; Value=$planName},
        @{Label='Computer'; Value=$env:COMPUTERNAME},
        @{Label='User'; Value=$env:USERNAME}
    )

    # Bestimme Spaltenbreite
    $maxLabel = ($entries | ForEach-Object {$_.Label.Length} | Measure-Object -Maximum).Maximum
    $maxValue = ($entries | ForEach-Object {$_.Value.Length} | Measure-Object -Maximum).Maximum
    $width = $maxLabel + $maxValue + 7
    $line = '‚îÄ' * $width

    # Header
    Write-Host "‚îå$line‚îê" -ForegroundColor Yellow
    $title = 'System-Informationen'
    $padTotal = $width - $title.Length
    $leftPad = ' ' * [math]::Floor($padTotal/2)
    $rightPad = ' ' * [math]::Ceiling($padTotal/2)
    Write-Host "‚îÇ$leftPad$title$rightPad‚îÇ" -ForegroundColor Cyan
    Write-Host "‚îú$line‚î§" -ForegroundColor Yellow

        # Eintr√§ge
    foreach ($e in $entries) {
        $lbl = $e.Label.PadRight($maxLabel)
        # Force value to string to avoid non-string types
        $strVal = [string]$e.Value
        $val = $strVal.PadLeft($maxValue)
        Write-Host ("‚îÇ {0} : {1} ‚îÇ" -f $lbl, $val) -ForegroundColor Green
    }

    # RAM Details
    Write-Host "‚îú$line‚î§" -ForegroundColor Yellow
    Write-Host "‚îÇ RAM Module Details:".PadRight($width+2) + "‚îÇ" -ForegroundColor Cyan
    foreach ($m in $ramModules) {
        $detail = ("{0} GB - {1} - {2} MHz" -f $m.SizeGB, $m.Manufacturer, $m.Speed)
        Write-Host ("‚îÇ   {0}" -f $detail).PadRight($width+2) + "‚îÇ" -ForegroundColor Green
    }

    # Footer
    Write-Host "‚îî$line‚îò`n" -ForegroundColor Yellow
    Start-Sleep -Seconds 7
    Clear-Host
}









function Apply-FPSOptimizations {
    Clear-Host
    Write-Host "`n$asciiLogo" -ForegroundColor Magenta
    Write-Host "`nüéÆ FPS-Optimierung wird angewendet..." -ForegroundColor Cyan

    # 1) H√∂chstleistungs-Energiemodus aktivieren
    powercfg -setactive SCHEME_MIN
    Write-Host "‚úÖ Energieplan: H√∂chstleistung" -ForegroundColor Green

    # 2) Hintergrund-Apps beenden
    Write-Host "üõë Beende Hintergrund-Apps..."
    Get-AppxPackage | Where-Object { $_.NonRemovable -eq $false } |
      ForEach-Object { Stop-Process -Name $_.Name -ErrorAction SilentlyContinue }
    Write-Host "‚úÖ Hintergrund-Apps gestoppt." -ForegroundColor Green

    # 3) Unn√∂tige Dienste deaktivieren
    Write-Host "üõ†Ô∏è Deaktiviere unn√∂tige Dienste..."
    $services = @("DiagTrack","SysMain","WSearch","RemoteRegistry","XboxGipSvc","TabletInputService")
    foreach ($s in $services) {
        Stop-Service -Name $s -Force -ErrorAction SilentlyContinue
        Set-Service -Name $s -StartupType Disabled -ErrorAction SilentlyContinue
    }
    Write-Host "‚úÖ Dienste deaktiviert." -ForegroundColor Green

    # 4) Windows-Animationen & Aero Peek ausschalten
    reg add "HKCU\Control Panel\Desktop" /v "FontSmoothing" /t REG_SZ /d 2 /f | Out-Null
    reg add "HKCU\Software\Microsoft\Windows\DWM" /v "EnableAeroPeek" /t REG_DWORD /d 0 /f | Out-Null
    Write-Host "‚úÖ Animationen & Aero Peek deaktiviert." -ForegroundColor Green

    # 5) Hardwarebeschleunigte GPU-Zeitplanung
    reg add "HKLM\SYSTEM\CurrentControlSet\Control\GraphicsDrivers" /v "HwSchMode" /t REG_DWORD /d 2 /f | Out-Null
    Write-Host "‚úÖ GPU-Zeitplanung aktiviert." -ForegroundColor Green

    # 6) GameDVR & Game Bar deaktivieren
    Write-Host "üìπ Deaktiviere GameDVR & Game Bar..."
    reg add "HKLM\SOFTWARE\Microsoft\PolicyManager\default\GameDVR" /v "AllowGameDVR" /t REG_DWORD /d 0 /f | Out-Null
    reg add "HKCU\System\GameConfigStore" /v "GameDVR_FSEBehavior" /t REG_DWORD /d 2 /f | Out-Null
    reg add "HKCU\Software\Microsoft\GameBar" /v "ShowStartupPanel" /t REG_DWORD /d 0 /f | Out-Null
    Write-Host "‚úÖ GameDVR & Game Bar deaktiviert." -ForegroundColor Green

    # 7) Fullscreen-Optimierungen abschalten
    reg add "HKCU\System\GameConfigStore" /v "GameDVR_UseShortcutFSEBehaviour" /t REG_DWORD /d 2 /f | Out-Null
    Write-Host "‚úÖ Fullscreen-Optimierungen deaktiviert." -ForegroundColor Green

    # 8) NVIDIA Low-Latency & ULPS deaktivieren
    if (Test-Path "HKLM:\SYSTEM\CurrentControlSet\Services\nvlddmkm") {
        reg add "HKLM\SYSTEM\CurrentControlSet\Services\nvlddmkm\Parameters" /v "EnableUlps" /t REG_DWORD /d 0 /f | Out-Null
        reg add "HKLM\SYSTEM\CurrentControlSet\Services\nvlddmkm\Parameters" /v "PowerMizerEnable" /t REG_DWORD /d 0 /f | Out-Null
        Write-Host "‚úÖ NVIDIA Low-Latency & ULPS deaktiviert." -ForegroundColor Green
    }

    # 9) PCIe Energiesparmodus (ASPM) deaktivieren
    powercfg /setacvalueindex SCHEME_MIN SUB_PCIEXPRESS ASPM 0 | Out-Null
    Write-Host "‚úÖ PCIe ASPM deaktiviert." -ForegroundColor Green

    # 10) CPU C-States deaktivieren
    Write-Host "üõë Deaktiviere CPU C-States..."
    reg add "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Power" /v "CsEnabled" /t REG_DWORD /d 0 /f | Out-Null
    Write-Host "‚úÖ CPU C-States deaktiviert." -ForegroundColor Green

    # 11) Netzwerk-Throttling & System-Responsiveness optimieren
    Write-Host "üì° Optimiere Netzwerk-Performance..."
    reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Multimedia\SystemProfile" /v "NetworkThrottlingIndex" /t REG_DWORD /d 4294967295 /f | Out-Null
    reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Multimedia\SystemProfile" /v "SystemResponsiveness" /t REG_DWORD /d 0 /f | Out-Null
    Write-Host "‚úÖ Netzwerk-Throttling deaktiviert & Responsiveness hochgesetzt." -ForegroundColor Green

    # 12) Prozess-Priorit√§t & Affinit√§t f√ºr Spielprozess
    $game = Read-Host "Name deines Spiel-Prozesses (z.B. csgo, Fortnite)"
    if (Get-Process -Name $game -ErrorAction SilentlyContinue) {
        $p = Get-Process -Name $game
        $p.PriorityClass = 'High'
        $p.ProcessorAffinity = 0xF # Kerne 0-3
        Write-Host "‚úÖ Priorit√§t & Affinit√§t gesetzt f√ºr $game." -ForegroundColor Green
    } else {
        Write-Host "‚ö†Ô∏è Prozess $game nicht gefunden." -ForegroundColor Yellow
    }

    # 13) Windows Defender Echtzeitschutz deaktivieren
    Write-Host "üõ°Ô∏è Deaktiviere Windows Defender Echtzeitschutz..."
    Set-MpPreference -DisableRealtimeMonitoring $true
    Write-Host "‚úÖ Defender Echtzeitschutz deaktiviert." -ForegroundColor Green

    # 14) Xbox Live-Dienste deaktivieren
    Write-Host "üéÆ Deaktiviere Xbox Live-Dienste..."
    $xbox = @("XblAuthManager","XblGameSave","XboxNetApiSvc")
    foreach ($svc in $xbox) {
        Stop-Service -Name $svc -Force -ErrorAction SilentlyContinue
        Set-Service -Name $svc -StartupType Disabled -ErrorAction SilentlyContinue
    }
    Write-Host "‚úÖ Xbox Live-Dienste deaktiviert." -ForegroundColor Green

    # 15) Fokusassistenz aktivieren (Quiet Hours)
    Write-Host "üîï Aktiviere Fokusassistenz (Quiet Hours)..."
    reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Notifications\Settings" /v "NOC_GLOBAL_SETTING_TOASTS_ENABLED" /t REG_DWORD /d 1 /f | Out-Null
    Write-Host "‚úÖ Fokusassistenz aktiviert." -ForegroundColor Green

    # 16) Windows Tipps & Vorschl√§ge deaktivieren
    Write-Host "üí° Deaktiviere Windows Tipps & Vorschl√§ge..."
    reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\ContentDeliveryManager" /v "SubscriptionsEnabled" /t REG_DWORD /d 0 /f | Out-Null
    reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\ContentDeliveryManager" /v "SystemPaneSuggestionsEnabled" /t REG_DWORD /d 0 /f | Out-Null
    Write-Host "‚úÖ Windows Tipps & Vorschl√§ge deaktiviert." -ForegroundColor Green

    Write-Host "üöÄ FPS-Optimierung abgeschlossen! Starte deinen PC neu f√ºr maximale Wirkung." -ForegroundColor Yellow
    Start-Sleep 3
    Clear-Host
}



# Funktion zur Installation von speedtest-cli (falls nicht vorhanden)
function Install-SpeedtestCLI {
    $speedtestExePath = "C:\Program Files\Speedtest\speedtest.exe"  # Zielpfad f√ºr die Installation

    # √úberpr√ºfe, ob speedtest.exe bereits existiert
    if (-not (Test-Path $speedtestExePath)) {
        Write-Host "‚ùå Speedtest.exe nicht gefunden. Starte die Installation..."

        # Stelle sicher, dass das Verzeichnis existiert
        $dir = [System.IO.Path]::GetDirectoryName($speedtestExePath)
        if (-not (Test-Path $dir)) {
            New-Item -ItemType Directory -Force -Path $dir
        }

        # Lade die speedtest-cli von der offiziellen Seite herunter
        $url = "https://install.speedtest.net/app/cli/ookla-speedtest-1.1.1-win64.zip"
        $zipPath = "$dir\speedtest.zip"
        
        # Lade die ZIP-Datei herunter
        Invoke-WebRequest -Uri $url -OutFile $zipPath
        Write-Host "‚úÖ Speedtest CLI wurde heruntergeladen."

        # Entpacke die ZIP-Datei
        Expand-Archive -Path $zipPath -DestinationPath $dir -Force
        Write-Host "‚úÖ Speedtest CLI wurde entpackt."

        # L√∂sche die ZIP-Datei nach der Installation
        Remove-Item -Path $zipPath -Force

        Write-Host "‚úÖ Speedtest CLI wurde erfolgreich installiert!" -ForegroundColor Green
    } else {
        Write-Host "‚úÖ Speedtest.exe ist bereits installiert!" -ForegroundColor Green
    }
}

# Funktion zur Messung der Netzwerkgeschwindigkeit
function Get-NetworkSpeed {
    $speedtestExePath = "C:\Program Files\Speedtest\speedtest.exe"  # Stelle sicher, dass der Pfad korrekt ist

    # Installiere speedtest-cli, wenn nicht vorhanden
    Install-SpeedtestCLI

    if (Test-Path $speedtestExePath) {
        # F√ºhre den Speedtest aus und akzeptiere sowohl die Lizenz als auch die Datenschutzrichtlinie
        $speedtestOutput = & $speedtestExePath --accept-license --accept-gdpr --progress=no --format=json | ConvertFrom-Json

        return @{
            Ping     = [math]::Round($speedtestOutput.ping.latency , 2)
            Download = [math]::Round($speedtestOutput.download.bandwidth / 125000, 2)
            Upload   = [math]::Round($speedtestOutput.upload.bandwidth / 125000, 2)
        }
    } else {
        Write-Host "‚ùå Die Datei 'speedtest.exe' wurde im angegebenen Pfad nicht gefunden. Bitte √ºberpr√ºfe den Pfad." -ForegroundColor Red
        return $null
    }
}

function Optimize-Network {
    Clear-Host
    Write-Host "`n$asciiLogo" -ForegroundColor Magenta
    Write-Host "`nüåê Netzwerk-Optimierungen werden angewendet..." -ForegroundColor Cyan

    $adapter = Get-NetAdapter | Where-Object { $_.Status -eq 'Up' } | Select-Object -First 1
    if (-not $adapter) {
        Write-Host "‚ùå Kein aktiver Netzwerkadapter gefunden." -ForegroundColor Red
        return
    }

    # 1) Adapter zur√ºcksetzen
    Write-Host "üîÑ Setze Netzwerkadapter $($adapter.Name) zur√ºck..."
    Disable-NetAdapter -Name $adapter.Name -Confirm:$false | Out-Null; Start-Sleep 3
    Enable-NetAdapter -Name $adapter.Name -Confirm:$false | Out-Null
    Write-Host "‚úÖ Adapter zur√ºckgesetzt." -ForegroundColor Green

    # 2) DNS auf Google DNS setzen
    Write-Host "üåê Setze DNS-Server auf 8.8.8.8, 8.8.4.4..."
    Set-DnsClientServerAddress -InterfaceIndex $adapter.InterfaceIndex -ServerAddresses ('8.8.8.8','8.8.4.4') | Out-Null
    Write-Host "‚úÖ DNS-Server gesetzt." -ForegroundColor Green

    # 3) MTU auf 1500 setzen
    Write-Host "‚öôÔ∏è Setze MTU auf 1500..."
    netsh interface ipv4 set subinterface "$($adapter.Name)" mtu=1500 store=persistent | Out-Null
    Write-Host "‚úÖ MTU ge√§ndert." -ForegroundColor Green

    # 4) TCP Autotuning deaktivieren
    Write-Host "üö´ Deaktiviere TCP Autotuning..."
    netsh interface tcp set global autotuninglevel=disabled | Out-Null
    Write-Host "‚úÖ Autotuning deaktiviert." -ForegroundColor Green

    # 5) ECN & SACK & Timestamps optimieren
    Write-Host "üìà Aktiviere RSS, deaktiviere ECN, SACK, Timestamps..."
    netsh interface tcp set global ecncapability=disabled | Out-Null
    netsh interface tcp set global rss=enabled | Out-Null
    netsh interface tcp set global timestamps=disabled | Out-Null
    netsh interface tcp set global nonsackrttresiliency=disabled | Out-Null
    Write-Host "‚úÖ TCP-Parameter optimiert." -ForegroundColor Green

    # 6) TCP Fast Open aktivieren
    Write-Host "üöÄ Aktiviere TCP Fast Open..."
    netsh interface tcp set global fastopen=enabled | Out-Null
    Write-Host "‚úÖ Fast Open aktiviert." -ForegroundColor Green

    # 7) Nagle Algorithmus deaktivieren
    Write-Host "üö´ Deaktiviere Nagle-Algorithmus..."
    Get-WmiObject Win32_NetworkAdapterConfiguration | Where-Object {$_.IPEnabled} | ForEach-Object {
        $path = "HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces\$($_.SettingID)"
        if (Test-Path $path) {
            New-ItemProperty -Path $path -Name "TcpAckFrequency" -Value 1 -PropertyType DWord -Force | Out-Null
            New-ItemProperty -Path $path -Name "TCPNoDelay" -Value 1 -PropertyType DWord -Force | Out-Null
            Write-Host "‚úÖ Nagle f√ºr $($_.Description) deaktiviert." -ForegroundColor Green
        }
    }

    # 8) RSC (Receive Side Coalescing) aktivieren
    Write-Host "üîß Aktiviere RSC f√ºr $($adapter.Name)..."
    Enable-NetAdapterRsc -Name $adapter.Name | Out-Null
    Write-Host "‚úÖ RSC aktiviert." -ForegroundColor Green

    # 9) Network Location Awareness (NlaSvc) deaktivieren
    Write-Host "üìç Deaktiviere Network Location Awareness..."
    try {
        Stop-Service -Name NlaSvc -Force -ErrorAction SilentlyContinue
        Set-Service -Name NlaSvc -StartupType Disabled | Out-Null
        Write-Host "‚úÖ Network Location Awareness deaktiviert." -ForegroundColor Green
    } catch {
        Write-Host "‚ö†Ô∏è Fehler beim Deaktivieren von NlaSvc: $($_.Exception.Message)" -ForegroundColor Yellow
    }

    # 10) QoS Packet Scheduler deaktivieren
    Write-Host "üìâ Deaktiviere QoS Packet Scheduler..."
    Set-NetAdapterBinding -Name $adapter.Name -ComponentID ms_pacer -Enabled $false | Out-Null
    Write-Host "‚úÖ QoS Scheduler deaktiviert." -ForegroundColor Green

    # 11) IPv6 deaktivieren
    Write-Host "üåê Deaktiviere IPv6..."
    Disable-NetAdapterBinding -Name $adapter.Name -ComponentID ms_tcpip6 | Out-Null
    Write-Host "‚úÖ IPv6 deaktiviert." -ForegroundColor Green

    # 12) LLMNR deaktivieren
    Write-Host "üîí Deaktiviere LLMNR..."
    reg add "HKLM\SOFTWARE\Policies\Microsoft\Windows NT\DNSClient" /v "EnableMulticast" /t REG_DWORD /d 0 /f | Out-Null
    Write-Host "‚úÖ LLMNR deaktiviert." -ForegroundColor Green

    # 13) NetBIOS over TCP/IP deaktivieren
    Write-Host "üö´ Deaktiviere NetBIOS over TCP/IP..."
    Get-WmiObject Win32_NetworkAdapterConfiguration | Where-Object { $_.IPEnabled } | ForEach-Object {
        $_.SetTcpipNetbios(2) | Out-Null
        Write-Host "‚úÖ NetBIOS f√ºr Adapter $($_.Description) deaktiviert." -ForegroundColor Green
    }

    # 14) Delivery Optimization deaktivieren
    Write-Host "üì¶ Deaktiviere Windows Delivery Optimization..."
    reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\DeliveryOptimization" /v "DODownloadMode" /t REG_DWORD /d 0 /f | Out-Null
    Write-Host "‚úÖ Delivery Optimization deaktiviert." -ForegroundColor Green

    # 15) SMB Signing deaktivieren
    Write-Host "üîê Deaktiviere SMB Signing..."
    reg add "HKLM\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters" /v "RequireSecuritySignature" /t REG_DWORD /d 0 /f | Out-Null
    Write-Host "‚úÖ SMB Signing deaktiviert." -ForegroundColor Green

    # 16) DNS Cache TTL erh√∂hen
    Write-Host "‚è≥ Setze DNS Cache TTL auf 86400 Sekunden..."
    reg add "HKLM\SYSTEM\CurrentControlSet\Services\Dnscache\Parameters" /v "MaxCacheTtl" /t REG_DWORD /d 86400 /f | Out-Null
    Write-Host "‚úÖ DNS TTL angepasst." -ForegroundColor Green

    # 17) ARP Cache Timeout reduzieren
    Write-Host "üîÑ Setze ARP Cache Timeout auf 120 Sekunden..."
    reg add "HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters" /v "ArpCacheLife" /t REG_DWORD /d 120 /f | Out-Null
    Write-Host "‚úÖ ARP Timeout gesetzt." -ForegroundColor Green

    # 18) DNS-Cache leeren
    Write-Host "üßπ Leere DNS-Cache..."
    ipconfig /flushdns | Out-Null
    Write-Host "‚úÖ DNS-Cache geleert." -ForegroundColor Green

    # 19) TCP Congestion Provider auf CTCP setzen
    Write-Host "üö¶ Setze TCP Congestion Provider auf CTCP..."
    netsh interface tcp set global congestionprovider=ctcp | Out-Null
    Write-Host "‚úÖ CTCP als Congestion Provider aktiviert." -ForegroundColor Green

    # 20) Teredo Tunneling deaktivieren
    Write-Host "üö´ Deaktiviere Teredo Tunneling..."
    netsh interface teredo set state disabled | Out-Null
    Write-Host "‚úÖ Teredo deaktiviert." -ForegroundColor Green

    # 21) Energy Efficient Ethernet deaktivieren, falls verf√ºgbar
    Write-Host "üõë Deaktiviere Energy Efficient Ethernet..."
    $eee = Get-NetAdapterAdvancedProperty -Name $adapter.Name -ErrorAction SilentlyContinue |
           Where-Object DisplayName -Match "Energy Efficient Ethernet"
    if ($eee) {
        Set-NetAdapterAdvancedProperty -Name $adapter.Name -DisplayName $eee.DisplayName -DisplayValue $eee.ValidValues[0] | Out-Null
        Write-Host "‚úÖ Energy Efficient Ethernet deaktiviert." -ForegroundColor Green
    } else {
        Write-Host "üü° Energy Efficient Ethernet nicht unterst√ºtzt." -ForegroundColor Yellow
    }

    Write-Host "üöÄ Netzwerk-Optimierung abgeschlossen! Starte deinen PC neu f√ºr volle Wirkung." -ForegroundColor Yellow
    Start-Sleep -Seconds 3
    Clear-Host
}







function Run-Speedtest {
    Clear-Host
    Write-Host "`nüöÄ Speedtest wird durchgef√ºhrt..." -ForegroundColor Cyan

    $speed = Get-NetworkSpeed
    
    $adapter = Get-NetAdapter | Where-Object { $_.Status -eq 'Up' } | Select-Object -First 1

    # Ausgabe-Schmuck
    $width = 50
    $line  = '‚îÄ' * $width
    Write-Host "`n‚îå$line‚îê" -ForegroundColor Yellow
    Write-Host ("‚îÇ {0,-12}: {1,8} ms" -f 'Ping', $speed.Ping) -ForegroundColor Green
    Write-Host ("‚îÇ {0,-12}: {1,8} Mbps" -f 'Download', $speed.Download) -ForegroundColor Green
    Write-Host ("‚îÇ {0,-12}: {1,8} Mbps" -f 'Upload',   $speed.Upload) -ForegroundColor Green
    Write-Host ("‚îÇ {0,-12}: {1,-24}" -f 'Adapter', $adapter.Name) -ForegroundColor Cyan
    
    Write-Host "‚îî$line‚îò`n" -ForegroundColor Yellow

    Start-Sleep -Seconds 5
}


function Optimize-RAM {
    Clear-Host
    Write-Host "`n$asciiLogo" -ForegroundColor Magenta
    Write-Host "`nüß† Starte RAM-Optimierung..." -ForegroundColor Cyan

    # 1) Freien RAM vorher auslesen
    $beforeRAM = (Get-CimInstance Win32_OperatingSystem).FreePhysicalMemory / 1024
    Write-Host "[Vorher] Freier RAM: $beforeRAM MB" -ForegroundColor Red

    # 2) Hintergrundprozesse beenden
    $processesToKill = @("OneDrive", "Skype", "Discord", "Teams", "Steam", "EpicGamesLauncher", "Battle.net", "chrome", "firefox", "msedge", "opera", "brave")
    foreach ($proc in $processesToKill) {
        if (Get-Process -Name $proc -ErrorAction SilentlyContinue) {
            Stop-Process -Name $proc -Force
            Write-Host "‚úÖ $proc wurde geschlossen!" -ForegroundColor Green
        }
    }

    # 3) Tempor√§re Dateien l√∂schen
    Write-Host "üóëÔ∏è L√∂sche tempor√§re Dateien..."
    $temp = [IO.Path]::GetTempPath()
    Get-ChildItem -Path $temp -Recurse -ErrorAction SilentlyContinue | Remove-Item -Force -Recurse -ErrorAction SilentlyContinue
    Write-Host "‚úÖ Tempor√§re Dateien entfernt." -ForegroundColor Green

    # 4) Papierkorb leeren
    Write-Host "üöÆ Leere Papierkorb..."
    try {
        Clear-RecycleBin -Force -ErrorAction Stop
        Write-Host "‚úÖ Papierkorb erfolgreich geleert." -ForegroundColor Green
    } catch {
        Write-Host "‚ùå Fehler beim Leeren des Papierkorbs: $_" -ForegroundColor Red
    }

    # 5) Clipboard leeren
    Write-Host "üìã Leere Zwischenablage..."
    Set-Clipboard -Value $null
    Write-Host "‚úÖ Zwischenablage geleert." -ForegroundColor Green

    # 6) System-Cache und Standby-Liste (sofern RAMMap installiert)
    Write-Host "üßπ Bereinige Standby-Liste (RAMMap needed)..."
    $ramMap = "$env:ProgramFiles\Sysinternals\RAMMap.exe"
    if (Test-Path $ramMap) {
        Start-Process -FilePath $ramMap -ArgumentList "/E" -Wait
        Write-Host "‚úÖ Standby-Liste bereinigt." -ForegroundColor Green
    } else {
        Write-Host "‚ö†Ô∏è RAMMap nicht gefunden, √ºbersprungen." -ForegroundColor Yellow
    }

    # 7) Paging-Executive deaktivieren
    Write-Host "‚öôÔ∏è Deaktiviere Paging Executive..."
    Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management" -Name "DisablePagingExecutive" -Value 1 -Type DWord -Force
    Write-Host "‚úÖ Paging Executive deaktiviert." -ForegroundColor Green

    # 8) Umgebungsvariablen f√ºr memory trimming
    Write-Host "üí° Konfiguriere Memory Trimming..."
    reg add "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management" /v "ClearPageFileAtShutdown" /t REG_DWORD /d 1 /f | Out-Null
    Write-Host "‚úÖ Pagefile bei Shutdown gel√∂scht." -ForegroundColor Green

    # 9) Nachher freier RAM anzeigen
    $afterRAM = (Get-CimInstance Win32_OperatingSystem).FreePhysicalMemory / 1024
    Write-Host "[Nachher] Freier RAM: $afterRAM MB" -ForegroundColor Green

    Write-Host "üöÄ RAM-Optimierung abgeschlossen! Starte deinen PC neu f√ºr maximale Wirkung." -ForegroundColor Yellow
    Start-Sleep 3
    Clear-Host
}


function Upgrade-Software {
    [CmdletBinding()]
    param()

    Clear-Host
    Write-Host "`n[+] Starte Software-Upgrade..." -ForegroundColor Cyan

    # 0) Winget pr√ºfen
    if (-not (Get-Command winget -ErrorAction SilentlyContinue)) {
        Write-Error "winget ist nicht installiert oder nicht im Pfad gefunden. Abbruch."; return
    }

    # 1) Quellen aktualisieren
    Write-Host "[>] Aktualisiere Winget-Quellen..." -ForegroundColor Yellow
    try { winget source update | Out-Null; Write-Host "[‚úî] Quellen aktualisiert." -ForegroundColor Green } 
    catch { Write-Host "[‚úñ] Fehler: $($_.Exception.Message)" -ForegroundColor Red }

    # 2) Verf√ºgbare Updates abrufen
    Write-Host "[i] Ermittele verf√ºgbare Updates..." -ForegroundColor Yellow
    $output = winget upgrade 2>&1
    # Header und Trennzeilen entfernen
    $data = $output -split "`n" | Where-Object { $_ -and $_ -notmatch '^(Usage:|Die folgenden|-----)' } | Select-Object -Skip 2
    if (-not $data) { Write-Host "[‚úî] Keine Updates gefunden." -ForegroundColor Green; return }

    # 3) Tabelle parsen und formatieren
    $rows = @()
    foreach ($line in $data) {
        $cols = $line.Trim() -split '\s+',5
        if ($cols.Count -ge 4) {
            $rows += [PSCustomObject]@{
                Name       = $cols[0]
                ID         = $cols[1]
                Version    = $cols[2]
                Available  = $cols[3]
                Source     = if ($cols.Count -ge 5) { $cols[4] } else { '' }
            }
        }
    }

    # Spaltenbreiten bestimmen
    $widths = @{
        Name      = ($rows.Name | Measure-Object -Property Length -Maximum).Maximum
        ID        = ($rows.ID   | Measure-Object -Property Length -Maximum).Maximum
        Version   = ($rows.Version | Measure-Object -Property Length -Maximum).Maximum
        Available = ($rows.Available | Measure-Object -Property Length -Maximum).Maximum
        Source    = ($rows.Source | Measure-Object -Property Length -Maximum).Maximum
    }

    # Header ausgeben
    Write-Host "`n[i] Folgende Pakete haben Updates:" -ForegroundColor Yellow
    $header = "  {0,-$($widths.Name)}  {1,-$($widths.ID)}  {2,-$($widths.Version)}  {3,-$($widths.Available)}  {4,-$($widths.Source)}" -f 'Nr', 'Name', 'Version', 'Verf√ºgbar', 'Quelle'
    Write-Host $header -ForegroundColor Cyan
    Write-Host ('-' * $header.Length) -ForegroundColor Cyan

    # Zeilen ausgeben
    for ($i=0; $i -lt $rows.Count; $i++) {
        $nr = $i+1
        $row = $rows[$i]
        $line = "{0,2} {1,-$($widths.Name)}  {2,-$($widths.ID)}  {3,-$($widths.Version)}  {4,-$($widths.Available)}  {5,-$($widths.Source)}" -f $nr, $row.Name, $row.ID, $row.Version, $row.Available, $row.Source
        Write-Host $line
    }
    Write-Host "[0] Abbrechen" -ForegroundColor Yellow

    # 4) Auswahl
    $sel = Read-Host "Gib die Nummern ein (z.B. 1,3,5) oder 'A' f√ºr alle"
    if ($sel -match '^[Aa]$') { $selection = 1..$rows.Count } 
    elseif ($sel -match '^[0-9, ]+$') { $selection = ($sel -split '[, ]+' | Where-Object { $_ -match '^\d+$' } | ForEach-Object { [int]$_ }) }
    else { Write-Host "[!] Ung√ºltige Auswahl." -ForegroundColor Yellow; return }

    # 5) Upgrade durchf√ºhren
    Write-Host "`n[*] F√ºhre ausgew√§hlte Upgrades durch..." -ForegroundColor Cyan
    foreach ($n in $selection) {
        if ($n -ge 1 -and $n -le $rows.Count) {
            $pkg = $rows[$n-1]
            Write-Host "‚Üí Aktualisiere $($pkg.Name) ($($pkg.ID)) auf $($pkg.Available)..." -ForegroundColor Cyan
            try { winget upgrade --id $pkg.ID --accept-package-agreements --accept-source-agreements | Out-Null; Write-Host "[‚úî] $($pkg.Name) aktualisiert." -ForegroundColor Green }
            catch { Write-Host "[‚úñ] Fehler bei $($pkg.Name): $($_.Exception.Message)" -ForegroundColor Red }
        }
    }

    Write-Host "`n[‚úî] Software-Upgrade abgeschlossen." -ForegroundColor Green
    Start-Sleep -Seconds 2; Clear-Host
}

function Optimize-Storage {
    Clear-Host
    Write-Host "`n$asciiLogo" -ForegroundColor Magenta
    Write-Host "`nüíæ Starte Datentr√§ger-Optimierung..." -ForegroundColor Cyan

    # 1) Freien Speicherplatz vorab ermitteln
    $drive     = Get-PSDrive C
    $beforeMB  = [math]::Round($drive.Free / 1MB, 2)
    Write-Host "[Vorher] Freier Speicherplatz: $beforeMB MB" -ForegroundColor Red

    # 2) Datentr√§gerbereinigung
    Write-Host "üßπ F√ºhre Datentr√§gerbereinigung aus..." -ForegroundColor Yellow
    Start-Process -NoNewWindow -Wait -FilePath "cleanmgr.exe" -ArgumentList "/sagerun:1"

    # 3) Tempor√§re Dateien l√∂schen
    Write-Host "üóëÔ∏è L√∂sche tempor√§re Dateien (%TEMP%)..." -ForegroundColor Yellow
    $temp = [IO.Path]::GetTempPath()
    Get-ChildItem $temp -Recurse -Force -ErrorAction SilentlyContinue |
      Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
    Write-Host "‚úÖ Tempor√§re Dateien weg." -ForegroundColor Green

    # 4) Prefetch leeren
    Write-Host "üöÄ Leere Prefetch-Ordner..." -ForegroundColor Yellow
    Get-ChildItem "C:\Windows\Prefetch" -Filter *.pf -ErrorAction SilentlyContinue |
      Remove-Item -Force -ErrorAction SilentlyContinue
    Write-Host "‚úÖ Prefetch geleert." -ForegroundColor Green

    # 5) Windows Update Cache zur√ºcksetzen
    Write-Host "üì¶ Leere Windows Update Cache..." -ForegroundColor Yellow
    Stop-Service wuauserv -Force -ErrorAction SilentlyContinue
    Remove-Item "C:\Windows\SoftwareDistribution\Download\*" -Recurse -Force -ErrorAction SilentlyContinue
    Start-Service wuauserv | Out-Null
    Write-Host "‚úÖ Update-Cache gel√∂scht." -ForegroundColor Green

    # 6) Event-Logs l√∂schen
    Write-Host "üìù Leere Event-Logs..." -ForegroundColor Yellow
    wevtutil el | ForEach-Object { wevtutil cl $_ } | Out-Null
    Write-Host "‚úÖ Event-Logs leer." -ForegroundColor Green

    # 7) SSD Trim (ReTrim)
    Write-Host "üîß F√ºhre SSD ReTrim aus..." -ForegroundColor Yellow
    Optimize-Volume -DriveLetter C -ReTrim -Verbose | Out-Null
    Write-Host "‚úÖ SSD ReTrim ausgef√ºhrt." -ForegroundColor Green

    # 8) Defragmentierung (f√ºr HDDs)
    Write-Host "üõ†Ô∏è Defragmentiere Volume C:..." -ForegroundColor Yellow
    Optimize-Volume -DriveLetter C -Defrag -Verbose | Out-Null
    Write-Host "‚úÖ Defragmentierung abgeschlossen." -ForegroundColor Green

    # 9) Freien Speicherplatz nachher ermitteln
    $afterMB = [math]::Round((Get-PSDrive C).Free / 1MB, 2)
    Write-Host "[Nachher] Freier Speicherplatz: $afterMB MB" -ForegroundColor Green

    Write-Host "üöÄ Datentr√§ger-Optimierung abgeschlossen! Starte deinen PC neu f√ºr volle Wirkung." -ForegroundColor Yellow
    Start-Sleep 3
    Clear-Host
}




function Enable-SystemRestore {
    # √úberpr√ºfen, ob die Systemwiederherstellung auf dem Systemlaufwerk aktiviert ist
$restoreStatus = Get-WmiObject -Class Win32_ShadowCopy

if ($restoreStatus -eq $null) {
    Write-Host "Systemwiederherstellung ist nicht aktiviert. Versuche, sie zu aktivieren..."

    # Systemwiederherstellung auf dem C-Laufwerk aktivieren
    Enable-ComputerRestore -Drive "C:\"

    Write-Host "Systemwiederherstellung wurde erfolgreich aktiviert!"
} else {
    Write-Host "Systemwiederherstellung ist bereits aktiviert."
}

# Wiederherstellungspunkt erstellen
try {
    # Wiederherstellungspunkt erstellen ohne den Tag-Parameter
    Checkpoint-Computer -Description "Wiederherstellungspunkt √ºber PowerShell erstellt"
    Write-Host "Wiederherstellungspunkt erfolgreich erstellt."
} catch {
    Write-Host "Es gab ein Problem beim Erstellen des Wiederherstellungspunkts: $_"
}

}
function Deinstall-Bloatware {
    Clear-Host
    Write-Host "`nüí£ Starte Bloatware-Entfernung..." -ForegroundColor Cyan

    # 1) Statische Liste erweiterter Bloatware-Apps
    $bloatwareApps = @(
        'Microsoft.XboxApp','Microsoft.ZuneMusic','Microsoft.ZuneVideo','Microsoft.MicrosoftSolitaireCollection',
        'Microsoft.YourPhone','Microsoft.People','Microsoft.Microsoft3DViewer','Microsoft.MicrosoftNews',
        'Microsoft.MicrosoftWeather','Microsoft.MicrosoftOfficeHub','Microsoft.GetHelp','Microsoft.GetStarted',
        'Microsoft.MicrosoftStickyNotes','Microsoft.Bing','Microsoft.OneDrive','Microsoft.SkypeApp',
        'Microsoft.OneDriveSync','Microsoft.Lync','Microsoft.SkypeForBusiness',
        'Microsoft.3DBuilder','Microsoft.WindowsMaps','Microsoft.People','Microsoft.WindowsCamera',
        'Microsoft.Microsoft3DViewer','Microsoft.MixedReality.Portal','Microsoft.Wallet','Microsoft.PPIProjection',
        'Microsoft.WindowsFeedbackHub'
    )

    # 2) Aktive Benutzer-Apps entfernen
    $removed=0; $skipped=0; $failed=0
    Write-Host "üö´ Entferne AppxPackage f√ºr Current User..." -ForegroundColor Yellow
    foreach ($appName in $bloatwareApps) {
        $apps = Get-AppxPackage -Name $appName -ErrorAction SilentlyContinue
        if ($apps) {
            foreach ($a in $apps) {
                Write-Host " - Entferne $($a.Name)..." -ForegroundColor Magenta
                try {
                    Remove-AppxPackage -Package $a.PackageFullName -ErrorAction Stop
                    $removed++;
                    Write-Host "   ‚úÖ entfernt." -ForegroundColor Green
                } catch {
                    $failed++;
                    Write-Warning "   ‚ö†Ô∏è konnte nicht entfernt werden: $($_.Exception.Message)"
                }
            }
        } else {
            $skipped++;
        }
    }

# 3) Provisioned Packages f√ºr alle Nutzer l√∂schen) Provisioned Packages f√ºr alle Nutzer l√∂schen
    Write-Host "üö´ Entferne Provisioned Packages (Systemweit)..." -ForegroundColor Yellow
    Get-AppxProvisionedPackage -Online | Where-Object DisplayName -In $bloatwareApps | ForEach-Object {
        $name = $_.DisplayName
        Write-Host " - Provisioned entfernen: $name..." -ForegroundColor Magenta
        try {
            Remove-AppxProvisionedPackage -Online -PackageName $_.PackageName -ErrorAction Stop | Out-Null
            Write-Host "   ‚úÖ $name entfernt." -ForegroundColor Green
        } catch {
            Write-Warning "   ‚ö†Ô∏è $name konnte nicht entfernt werden: $($_.Exception.Message)"
        }
    }

# 4) Deaktivieren von Consumer Experience Features
    Write-Host "üîí Deaktiviere Consumer Experience..." -ForegroundColor Yellow
    # Stelle sicher, dass der Explorer-Policy-Pfad existiert
    $regPath = 'HKLM:\SOFTWARE\Policies\Microsoft\Windows\Explorer'
    if (-not (Test-Path $regPath)) {
        New-Item -Path 'HKLM:\SOFTWARE\Policies\Microsoft\Windows' -Name 'Explorer' -Force | Out-Null
        Write-Host "   ‚úÖ Registry-Pfad f√ºr Explorer erstellt." -ForegroundColor Green
    }
    try {
        New-ItemProperty -Path $regPath -Name "DisableNewAppAlert" -PropertyType DWord -Value 1 -Force | Out-Null
        New-ItemProperty -Path $regPath -Name "DisableWindowsConsumerFeatures" -PropertyType DWord -Value 1 -Force | Out-Null
        Write-Host "   ‚úÖ Consumer Features deaktiviert." -ForegroundColor Green
    } catch {
        Write-Warning "   ‚ö†Ô∏è Consumer Features konnten nicht vollst√§ndig deaktiviert werden: $($_.Exception.Message)"
    }

# 5) Entferne zugeh√∂rige Scheduled Tasks
    Write-Host "üóìÔ∏è Entferne Windows Tips & Cortana Tasks..." -ForegroundColor Yellow
    $tasks = @( 
        '\Microsoft\Windows\Shell\FamilySafetyUpdateTask',
        '\Microsoft\Windows\CloudExperienceHost\CreateObjectTask',
        '\Microsoft\Windows\CloudExperienceHost\BingSearchUpdate'
    )
    foreach ($t in $tasks) {
        schtasks /Change /TN $t /Disable 2>$null
    }
    Write-Host "‚úÖ Geplante Consumer Tasks deaktiviert." -ForegroundColor Green

    Write-Host "‚úÖ Bloatware-Entfernung abgeschlossen!" -ForegroundColor Cyan
    Start-Sleep 3
    Clear-Host
}









function Apply-CPUOptimizations {
    Clear-Host
    Write-Host "`n‚ö° CPU-Optimierung wird gestartet..." -ForegroundColor Cyan

    # 1) H√∂chstleistungs-Energiemodus aktivieren
    Write-Host "üîã Setze Energieoptionen auf H√∂chstleistung..."
    powercfg -setactive SCHEME_MIN > $null
    Write-Host "‚úÖ Energieoptionen auf H√∂chstleistung gesetzt." -ForegroundColor Green

    # 2) Prozessorleistung auf 100%
    Write-Host "üìà Setze minimale/maximale Prozessorleistung auf 100%..."
    powercfg /setacvalueindex SCHEME_MIN SUB_PROCESSOR PROCTHROTTLEMIN 100 | Out-Null
    powercfg /setacvalueindex SCHEME_MIN SUB_PROCESSOR PROCTHROTTLEMAX 100 | Out-Null
    Write-Host "‚úÖ CPU-Leistungsgrenzen angepasst." -ForegroundColor Green

    # 3) PCIe Energiesparmodus (ASPM) deaktivieren
    Write-Host "üîå Deaktiviere PCIe Energiesparmodus (ASPM)..."
    powercfg /setacvalueindex SCHEME_MIN SUB_PCIEXPRESS ASPM 0 | Out-Null
    Write-Host "‚úÖ PCIe ASPM deaktiviert." -ForegroundColor Green

    # 4) CPU-Interrupt-Steuerung optimieren
    Write-Host "üîß Optimiere CPU-Interrupt-Steuerung..."
    reg add "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Kernel" /v "InterruptSteering" /t REG_DWORD /d 1 /f > $null
    Write-Host "‚úÖ Interrupt-Steuerung optimiert." -ForegroundColor Green

    # 5) CPU-Parkmodus deaktivieren
    Write-Host "üöÄ Deaktiviere CPU-Parking..."
    reg add "HKLM\SYSTEM\CurrentControlSet\Control\Power\PowerSettings\54533251-82be-4824-96c1-47b60b740d00\0cc5b647-c1df-4637-891a-dec35c318583" /v "Attributes" /t REG_DWORD /d 0 /f > $null
    Write-Host "‚úÖ CPU-Parkmodus deaktiviert." -ForegroundColor Green

    # 6) Dynamische Frequenzskalierung abschalten
    Write-Host "‚öôÔ∏è Deaktiviere CPU-Drosselung..."
    reg add "HKLM\SYSTEM\CurrentControlSet\Control\Power\PowerThrottling" /v "PowerThrottlingOff" /t REG_DWORD /d 1 /f > $null
    Write-Host "‚úÖ CPU-Frequenz bleibt stabil." -ForegroundColor Green

    # 7) Prozessor Scheduling f√ºr Programme
    Write-Host "üóÇÔ∏è Setze Prozessor-Scheduling auf Programme..."
    reg add "HKLM\SYSTEM\CurrentControlSet\Control\PriorityControl" /v "Win32PrioritySeparation" /t REG_DWORD /d 26 /f > $null
    Write-Host "‚úÖ Scheduling auf Programme angepasst." -ForegroundColor Green

    # 8) Prefetch & Superfetch deaktivieren
    Write-Host "üõë Deaktiviere Prefetch und Superfetch..."
    reg add "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PrefetchParameters" /v "EnablePrefetcher" /t REG_DWORD /d 0 /f > $null
    reg add "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PrefetchParameters" /v "EnableSuperfetch" /t REG_DWORD /d 0 /f > $null
    Write-Host "‚úÖ Prefetch und Superfetch deaktiviert." -ForegroundColor Green

    # 9) Mikrosekundengenaue Timer aktivieren
    Write-Host "üïí Optimiere CPU-Timer-Aufl√∂sung..."
    reg add "HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation" /v "RealTimeIsUniversal" /t REG_DWORD /d 1 /f > $null
    Write-Host "‚úÖ Hochpr√§ziser CPU-Timer aktiviert." -ForegroundColor Green

    # 10) Hyper-Threading aktivieren (Intel)
    if ($env:PROCESSOR_IDENTIFIER -match "Intel") {
        Write-Host "üîç Erkenne Intel Hyper-Threading..."
        reg add "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Kernel" /v "DisableHyperthreading" /t REG_DWORD /d 0 /f > $null
        Write-Host "‚úÖ Hyper-Threading ist aktiviert (falls unterst√ºtzt)." -ForegroundColor Green
    }

    # 11) Performance Boost Mode konfigurieren
    Write-Host "üí• Aktiviere Performance Boost Mode..."
    reg add "HKLM\SYSTEM\CurrentControlSet\Control\Power\PowerSettings\54533251-82be-4824-96c1-47b60b740d00\bc5038f7-23e0-4960-96da-33abaf5935ec" /v "Attributes" /t REG_DWORD /d 0 /f > $null
    powercfg /setacvalueindex SCHEME_MIN SUB_PROCESSOR BC5038F7-23E0-4960-96DA-33ABAF5935EC 2 | Out-Null
    Write-Host "‚úÖ Performance Boost Mode gesetzt." -ForegroundColor Green

    # 12) Hochpr√§zise Timer im Bootloader
    Write-Host "‚è±Ô∏è Aktiviere UsePlatformClock..."
    bcdedit /set useplatformclock true | Out-Null
    Write-Host "‚úÖ Hochpr√§zise Timer im Bootloader aktiviert." -ForegroundColor Green

    # 13) Dynamischen Tick deaktivieren
    Write-Host "‚è≥ Deaktiviere dynamischen Tick..."
    bcdedit /set disabledynamictick yes | Out-Null
    Write-Host "‚úÖ Dynamischer Tick deaktiviert." -ForegroundColor Green

    Write-Host "üöÄ CPU-Optimierung abgeschlossen! Starte deinen PC neu f√ºr maximale Wirkung." -ForegroundColor Yellow
    Start-Sleep 3
    Clear-Host
}




function Deactivate-Telemetry {
    Clear-Host
    Write-Host "`nüîí Deaktiviere Telemetrie & Diagnosedaten..." -ForegroundColor Cyan

    # 1Ô∏è‚É£ Relevante Telemetrie-Dienste stoppen & deaktivieren
    $services = @(
        "DiagTrack",
        "dmwappushservice",
        "WMPNetworkSvc",
        "RetailDemo",
        "diagnosticshub.standardcollector.service"
    )
    foreach ($svc in $services) {
        if (Get-Service $svc -ErrorAction SilentlyContinue) {
            Stop-Service $svc -Force -ErrorAction SilentlyContinue
            Set-Service  $svc -StartupType Disabled -ErrorAction SilentlyContinue
            Write-Host "‚úì Dienst deaktiviert: $svc" -ForegroundColor Green
        }
    }

    # 2Ô∏è‚É£ Geplante Telemetrie-Tasks abschalten
    $tasks = @(
        "\Microsoft\Windows\Application Experience\Microsoft Compatibility Appraiser",
        "\Microsoft\Windows\Application Experience\ProgramDataUpdater",
        "\Microsoft\Windows\Autochk\Proxy",
        "\Microsoft\Windows\Customer Experience Improvement Program\Consolidator",
        "\Microsoft\Windows\Customer Experience Improvement Program\UsbCeip",
        "\Microsoft\Windows\DiskDiagnostic\Microsoft-Windows-DiskDiagnosticDataCollector"
    )
    foreach ($t in $tasks) {
        schtasks /Change /TN $t /Disable 2>$null
        Write-Host "‚úì Task deaktiviert: $t" -ForegroundColor Green
    }

    # 3Ô∏è‚É£ Registry-Eintr√§ge zur Telemetrie-Anpassung
    $registryPaths = @{
        "HKLM:\SOFTWARE\Policies\Microsoft\Windows\DataCollection"               = "AllowTelemetry";
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\DataCollection" = "AllowTelemetry";
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer"       = "AllowTelemetry";
        "HKLM:\SOFTWARE\Policies\Microsoft\Windows\AppCompat"                     = "AITEnable";
    }
    foreach ($path in $registryPaths.Keys) {
        if (-not (Test-Path $path)) {
            New-Item -Path $path -Force | Out-Null
        }
        Set-ItemProperty -Path $path -Name $registryPaths[$path] -Value 0 -Force
        Write-Host "‚úì Registry gesetzt: $path -> $($registryPaths[$path])=0" -ForegroundColor Green
    }

    # 4Ô∏è‚É£ Defender-Cloud-Reporting abschalten
    Set-MpPreference -SubmitSamplesConsent NeverSend -MAPSReporting 0
    Write-Host "‚úì Defender Cloud Reporting deaktiviert" -ForegroundColor Green

    Write-Host "`nüéâ Telemetrie komplett abgeschaltet." -ForegroundColor Cyan
    Start-Sleep 3
    Clear-Host
}





function Set-PowerPlanMenu {
    Clear-Host
    Write-Host "`nüîã Verf√ºgbare Energiepl√§ne:" -ForegroundColor Cyan

    # Alle Pl√§ne per WMI auslesen
    $allPlans = Get-CimInstance -Namespace root\cimv2\power Win32_PowerPlan |
                ForEach-Object {
                    [PSCustomObject]@{
                        Name     = $_.ElementName
                        Guid     = ($_.InstanceID -split '\\')[-1]
                        IsActive = $_.IsActive
                    }
                }

    # Anzeige mit Kennzeichnung des aktiven Plans
    for ($i = 0; $i -lt $allPlans.Count; $i++) {
        $plan = $allPlans[$i]
        if ($plan.IsActive) {
		$marker = '*'
		} else {
		$marker = ' '
		}

        Write-Host "[$($i+1)] $($plan.Name) $marker" -ForegroundColor Green
    }
    Write-Host "[0] Abbrechen" -ForegroundColor Yellow

    $choice = Read-Host "W√§hle einen Plan (Nummer)"
    if ($choice -match '^\d+$' -and $choice -gt 0 -and $choice -le $allPlans.Count) {
        $sel = $allPlans[$choice - 1]
        powercfg -setactive $sel.Guid
        Write-Host "‚úÖ Energieplan gesetzt auf: $($sel.Name)" -ForegroundColor Cyan
    } else {
        Write-Host "‚ÑπÔ∏è Abbruch oder ung√ºltige Auswahl." -ForegroundColor Yellow
    }

    Start-Sleep 3
    Clear-Host
}


function New-HighFPSPowerPlan {
    [CmdletBinding()]
    param ()

    Write-Host "`n‚ö° Erstelle ultimativen Performance Power Plan auf Basis 'Energiesparmodus'..." -ForegroundColor Cyan

    # 1) Basis-Plan ermitteln (englisch "Power Saver" oder deutsch "Energiesparmodus")
    Write-Host "üîç Suche Power Saver-/Energiesparmodus-Plan..." -ForegroundColor Yellow
    $schemeLines = powercfg /List
    $baseLine   = $schemeLines | Where-Object { $_ -match 'Power Saver|Energiesparmodus' }
    if ($baseLine -match '([0-9A-Fa-f]{8}(?:-[0-9A-Fa-f]{4}){3}-[0-9A-Fa-f]{12})') {
        $baseGuid = $Matches[1]
        Write-Host "‚úÖ Basis-Plan GUID: $baseGuid" -ForegroundColor Green
    } else {
        Write-Error "Basis-Plan 'Power Saver' bzw. 'Energiesparmodus' nicht gefunden. Abbruch."
        return
    }

    # 2) Klon erstellen und GUID extrahieren
    Write-Host "üìù Klone den Basis-Plan..." -ForegroundColor Yellow
    $dupOutput = powercfg /duplicatescheme $baseGuid
    $guidMatch = $dupOutput |
        Select-String -Pattern '[0-9A-Fa-f]{8}(?:-[0-9A-Fa-f]{4}){3}-[0-9A-Fa-f]{12}' |
        Select-Object -First 1

    if ($guidMatch) {
        $newGuid = $guidMatch.Matches[0].Value
        Write-Host "‚úÖ Neuer Plan GUID: $newGuid" -ForegroundColor Green
    } else {
        Write-Error "Fehler beim Klonen des Plans. Abbruch."
        return
    }

    # 3) Neuen Plan umbenennen inkl. Beschreibung
    $newName = "PCTest Powerplan"
    $newDesc = "Maximale Leistungseinstellungen f√ºr FPS-intensive und Power-User-Anwendungen"
    Write-Host "‚úèÔ∏è Setze Name und Beschreibung auf '$newName' / '$newDesc'..." -ForegroundColor Yellow
    powercfg /changename $newGuid "$newName" "$newDesc"

    # Hilfsfunktion f√ºr AC/DC Einstellungen
    function Set-Index {
        param($sub, $setting, $value)
        Write-Host "   - Setze $setting auf $value..." -ForegroundColor Cyan
        powercfg /setacvalueindex $newGuid $sub $setting $value | Out-Null
        powercfg /setdcvalueindex $newGuid $sub $setting $value | Out-Null
    }

    # 4) CPU Throttling auf 100%
    Write-Host "üîß Konfiguriere CPU Throttling..." -ForegroundColor Yellow
    $procSub = '54533251-82be-4824-96c1-47b60b740d00'
    Set-Index $procSub '893dee8e-2bef-41e0-89c6-b55d0929964c' 100
    Set-Index $procSub 'bc5038f7-23e0-4960-96da-33abaf5935ec' 100

    # 5) CPU C-States deaktivieren
    Write-Host "üîí Deaktiviere CPU C-States..." -ForegroundColor Yellow
    $cStateSub = '238c9fa8-0aad-41ed-83f4-97be242c8f20'
    Set-Index $cStateSub '3b04d4fd-1cc7-4f23-8287-3b3660f74a66' 0

    # 6) PCIe ASPM deaktivieren
    Write-Host "‚úÇÔ∏è Deaktiviere PCIe ASPM..." -ForegroundColor Yellow
    $pcieSub = '501a4d13-42af-4429-9fd1-a8218c268e20'
    Set-Index $pcieSub 'ee12f906-d277-404b-b6da-e5fa1a576df5' 0

    # 7) System Cooling Policy = Active
    Write-Host "üå°Ô∏è Setze System Cooling Policy auf Active..." -ForegroundColor Yellow
    Set-Index $cStateSub '94d3a615-a899-4ac5-ae2b-e4d8f634367f' 0

    # 8) Performance Boost Mode = Aggressive
    Write-Host "üöÄ Aktiviere Performance Boost Mode..." -ForegroundColor Yellow
    $boostSub = '45bcc044-d885-43e2-8605-ee0ec6e96b59'
    Set-Index $boostSub 'be337238-0d82-4146-a960-4f3749d470c7' 2

    # 9) Network Throttling deaktivieren
    Write-Host "üåê Deaktiviere Network Throttling..." -ForegroundColor Yellow
    $netSub = 'b5d880f7-4841-4872-8aad-7e4325b58f78'
    Set-Index $netSub 'e2761301-3825-4dcd-b20c-31f197c53bb2' 0

    # 10) System Responsiveness auf 100
    Write-Host "‚ö° Setze System Responsiveness auf 100..." -ForegroundColor Yellow
    $respSub = '9d7815a6-7ee4-497e-8888-515a05f02364'
    Set-Index $respSub '5c5bb349-ad29-4ee2-ade2-1e1de703e917' 100

    # 11) Plan aktivieren
    Write-Host "üîî Aktiviere neuen Power Plan..." -ForegroundColor Yellow
    powercfg /setactive $newGuid

    Start-Sleep 10
    Clear-Host
}

function Update-Windows {
    Clear-Host
    Write-Host "`nüîÑ Windows Update-Check & Installation" -ForegroundColor Cyan
    Write-Host "======================================" -ForegroundColor Yellow

    # 1Ô∏è‚É£ Modul laden / installieren
    if (-not (Get-Module PSWindowsUpdate -ListAvailable)) {
        Write-Host "[1/4] PSWindowsUpdate Modul fehlt ‚Äì installiere‚Ä¶" -ForegroundColor Yellow
        try {
            Install-PackageProvider -Name NuGet -Force -Scope CurrentUser | Out-Null
            Install-Module PSWindowsUpdate -Force -Scope CurrentUser -AllowClobber | Out-Null
            Write-Host "    ‚úì Modul installiert" -ForegroundColor Green
        } catch {
            Write-Host "    ‚úñ Fehler beim Modul-Install: $($_.Exception.Message)" -ForegroundColor Red
            return
        }
    } else {
        Write-Host "[1/4] PSWindowsUpdate Modul geladen" -ForegroundColor Green
    }
    Import-Module PSWindowsUpdate

    # 2Ô∏è‚É£ Suche nach Updates
    Write-Host "[2/4] Suche nach verf√ºgbaren Updates‚Ä¶" -ForegroundColor Yellow
    $updates = Get-WindowsUpdate -AcceptAll -IgnoreUserInput | Tee-Object -Variable found
    if (-not $updates) {
        Write-Host "    ‚úì Keine Updates gefunden." -ForegroundColor Green
        Start-Sleep 2
        return
    }
    Write-Host "    ‚ö†Ô∏è Updates gefunden: $($updates.Count)" -ForegroundColor Magenta

    # 3Ô∏è‚É£ Installiere Updates mit Fortschritt
    Write-Host "[3/4] Installation l√§uft‚Ä¶ Bitte warten." -ForegroundColor Yellow
    $total = $updates.Count
    for ($i=0; $i -lt $total; $i++) {
        $u = $updates[$i]
        $percent = [int](($i / $total) * 100)
        Write-Progress -Activity "Windows Update" -Status "Installiere: $($u.Title)" -PercentComplete $percent
        Install-WindowsUpdate -KBArticleID $u.KB -AcceptAll -AutoReboot -IgnoreReboot -Verbose:$false | Out-Null
    }
    Write-Progress -Activity "Windows Update" -Completed

    # 4Ô∏è‚É£ Abschluss & Neustart pr√ºfen
    Write-Host "[4/4] Alle Updates installiert." -ForegroundColor Green
    if (Test-Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired) {
        Write-Host "‚û°Ô∏è  Neustart erforderlich‚Ä¶ starte in 10 Sekunden" -ForegroundColor Yellow
        Start-Sleep -Seconds 10
        Restart-Computer -Force
    } else {
        Write-Host "‚û°Ô∏è  Kein Neustart n√∂tig." -ForegroundColor Cyan
    }
    Start-Sleep 3
    Clear-Host
}


function Run-Benchmark {
    Clear-Host
    Write-Host "`nüèÅ Starte System-Benchmark‚Ä¶" -ForegroundColor Cyan
    Write-Host "----------------------------------" -ForegroundColor Yellow

    # 1Ô∏è‚É£ CPU-Test
    Write-Host "`n[CPU] Berechne 1.000.000 Quadratwurzeln‚Ä¶" -ForegroundColor Cyan
    $cpuTime = Measure-Command {
        1..1000000 | ForEach-Object { [math]::Sqrt($_) } | Out-Null
    }
    Write-Host ("‚Üí CPU: {0:N2} s" -f $cpuTime.TotalSeconds) -ForegroundColor Green

    # 2Ô∏è‚É£ Intensiver Festplatten‚ÄêTest (100 MB + Random I/O)
    Write-Host "`n[Disk] Sequenzieller & zuf√§lliger I/O Test (100 MB) ‚Ä¶" -ForegroundColor Cyan

    $file      = Join-Path $env:TEMP 'bench_disk.tmp'
    $sizeMB    = 100
    $mb        = 1024 * 1024
    $totalSize = $sizeMB * $mb
    $chunkSize = 1 * $mb
    $chunks    = $sizeMB
    $rand      = New-Object Random

    # Sequenzieller Write-Buffer
    $seqBuffer = New-Object byte[] $chunkSize
    $rand.NextBytes($seqBuffer)

    # Seq Write
    $seqWrite = Measure-Command {
        $fs = [IO.File]::Open($file, 'Create', 'Write')
        for ($i = 0; $i -lt $chunks; $i++) {
            $fs.Write($seqBuffer, 0, $chunkSize)
        }
        $fs.Close()
    }
    Write-Host ("   ‚Üí Seq Write: {0:N2} MB/s" -f ($sizeMB / $seqWrite.TotalSeconds)) -ForegroundColor Green

    # Random-Write (20 I/Os √† 4 MB)
    $randChunk   = 4 * $mb
    $randWrites  = 20
    $randBuffer  = New-Object byte[] $randChunk    # puffert jetzt 4 MB!
    $rand.NextBytes($randBuffer)

    $randWrite = Measure-Command {
        $fs = [IO.File]::Open($file, 'Open', 'ReadWrite')
        for ($i = 0; $i -lt $randWrites; $i++) {
            $pos = $rand.Next(0, $totalSize - $randChunk)
            $fs.Position = $pos
            $fs.Write($randBuffer, 0, $randChunk)
        }
        $fs.Close()
    }
    Write-Host ("   ‚Üí Rand Write: {0:N2} IOPS" -f ($randWrites / $randWrite.TotalSeconds)) -ForegroundColor Green

    # Sequenzieller Read
    $seqRead = Measure-Command {
        $fs     = [IO.File]::OpenRead($file)
        $readBuf = New-Object byte[] $chunkSize
        while ($fs.Read($readBuf, 0, $chunkSize) -gt 0) { }
        $fs.Close()
    }
    Write-Host ("   ‚Üí Seq Read: {0:N2} MB/s" -f ($sizeMB / $seqRead.TotalSeconds)) -ForegroundColor Green

    # Random-Read (20 I/Os √† 4 MB)
    $randRead = Measure-Command {
        $fs     = [IO.File]::OpenRead($file)
        $readBuf = New-Object byte[] $randChunk       # hier ebenfalls 4 MB-Puffer
        for ($i = 0; $i -lt $randWrites; $i++) {
            $pos = $rand.Next(0, $totalSize - $randChunk)
            $fs.Position = $pos
            $fs.Read($readBuf, 0, $randChunk) | Out-Null
        }
        $fs.Close()
    }
    Write-Host ("   ‚Üí Rand Read: {0:N2} IOPS" -f ($randWrites / $randRead.TotalSeconds)) -ForegroundColor Green

    Remove-Item $file -Force

    # 3Ô∏è‚É£ RAM-Test (500 MB)
    Write-Host "`n[RAM] Allociere & f√ºlle 500 MB Array‚Ä¶" -ForegroundColor Cyan
    $mb      = 1024 * 1024
    $memSize = 500 * $mb
    $memTime = Measure-Command {
        $arr = New-Object byte[] $memSize
        for ($i = 0; $i -lt $arr.Length; $i += 4096) {
            $arr[$i] = 1
        }
    }
    Write-Host ("‚Üí RAM:   {0:N2} s" -f $memTime.TotalSeconds) -ForegroundColor Green

    Write-Host "`nüèÅ Benchmark abgeschlossen!" -ForegroundColor Yellow
    Start-Sleep 7
    Clear-Host
}










# Verbesserte Men√º-Funktionen

function Show-NetworkMenu {
    while ($true) {
        Clear-Host
        Write-Host "`n$asciiLogo" -ForegroundColor Magenta
        Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Yellow
        Write-Host "‚ïë        üåê Netzwerk-Men√º       ‚ïë" -ForegroundColor Cyan
        Write-Host "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£" -ForegroundColor Yellow
        Write-Host "‚ïë 1) Netzwerk optimieren      ‚ïë" -ForegroundColor Green
        Write-Host "‚ïë 2) Speedtest ausf√ºhren       ‚ïë" -ForegroundColor Green
        Write-Host "‚ïë 3) Zur√ºck zum Hauptmen√º      ‚ïë" -ForegroundColor Green
        Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Yellow
        $choice = Read-Host "Auswahl (1-3)"
        switch ($choice) {
            '1' { Optimize-Network }
            '2' { Run-Speedtest }
            '3' { return }
            default { Write-Host "Ung√ºltige Auswahl!" -ForegroundColor Red; Start-Sleep 1 }
        }
    }
}

function Show-PerformanceMenu {
    while ($true) {
        Clear-Host
        Write-Host "`n$asciiLogo" -ForegroundColor Magenta
        Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Yellow
        Write-Host "‚ïë      ‚öôÔ∏è Performance-Men√º      ‚ïë" -ForegroundColor Cyan
        Write-Host "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£" -ForegroundColor Yellow
        Write-Host "‚ïë 1) FPS Optimierung          ‚ïë" -ForegroundColor Green
        Write-Host "‚ïë 2) CPU Optimierung          ‚ïë" -ForegroundColor Green
        Write-Host "‚ïë 3) RAM Optimierung          ‚ïë" -ForegroundColor Green
        Write-Host "‚ïë 4) Speicher Optimierung     ‚ïë" -ForegroundColor Green
        Write-Host "‚ïë 5) Power-Plan ausw√§hlen     ‚ïë" -ForegroundColor Green
		Write-Host "‚ïë 6) Benchmark durchf√ºhren     ‚ïë" -ForegroundColor Green
        Write-Host "‚ïë 7) Zur√ºck zum Hauptmen√º     ‚ïë" -ForegroundColor Green
        Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Yellow
        $choice = Read-Host "Auswahl (1-7)"
        switch ($choice) {
            '1' { Apply-FPSOptimizations }
            '2' { Apply-CPUOptimizations }
            '3' { Optimize-RAM }
            '4' { Optimize-Storage }
            '5' { New-HighFPSPowerPlan }
			'6' { Run-Benchmark }

            '7' { return }
            default { Write-Host "Ung√ºltige Auswahl!" -ForegroundColor Red; Start-Sleep 1 }
        }
    }
}

function Show-WindowsMenu {
    while ($true) {
        Clear-Host
        Write-Host "`n$asciiLogo" -ForegroundColor Magenta

        # Men√º-Box f√ºr Windows-Tools
        $opts = @(
            '1) Bloatware entfernen',
            '2) Telemetrie deaktivieren',
            '3) Windows Update',
            '4) Zur√ºck zum Hauptmen√º'
        )
        $width  = ($opts | Measure-Object -Property Length -Maximum).Maximum + 4
        $top    = '‚ïî' + ('‚ïê' * $width) + '‚ïó'
        $title  = 'üõ†Ô∏è Windows-Men√º'
        $titleLine = '‚ïë' + (' ' * [math]::Floor(($width - $title.Length)/2)) + $title + (' ' * [math]::Ceiling(($width - $title.Length)/2)) + '‚ïë'
        $sep    = '‚ï†' + ('‚ïê' * $width) + '‚ï£'
        $bottom = '‚ïö' + ('‚ïê' * $width) + '‚ïù'

        Write-Host ($top.PadLeft(([console]::WindowWidth + $top.Length)/2)) -ForegroundColor Yellow
        Write-Host ($titleLine.PadLeft(([console]::WindowWidth + $titleLine.Length)/2)) -ForegroundColor Cyan
        Write-Host ($sep.PadLeft(([console]::WindowWidth + $sep.Length)/2)) -ForegroundColor Yellow

        foreach ($opt in $opts) {
            $line = '‚ïë  ' + $opt.PadRight($width - 2) + '‚ïë'
            Write-Host ($line.PadLeft(([console]::WindowWidth + $line.Length)/2)) -ForegroundColor Green
        }

        Write-Host ($bottom.PadLeft(([console]::WindowWidth + $bottom.Length)/2)) -ForegroundColor Yellow

        $choice = Read-Host "Auswahl (1-4)"
        switch ($choice) {
            '1' { Deinstall-Bloatware }
            '2' { Deactivate-Telemetry }
            '3' { Update-Windows }
            '4' { return }
            default {
                Write-Host "Ung√ºltige Auswahl ‚Äì bitte 1‚Äì4 eingeben." -ForegroundColor Red
                Start-Sleep 1
            }
        }
    }
}


function Show-Menu {
    param([string]$asciiLogo)

    # Erste Abfrage zum Wiederherstellungspunkt
    $resp = Read-Host "Wiederherstellungspunkt erstellen? (J/N)"
    if ($resp -match '^[Jj]$') { Enable-SystemRestore }

    while ($true) {
        Clear-Host
        # Logo zentriert
        $logoLines = $asciiLogo -split "`n"
        foreach ($line in $logoLines) {
            Write-Host ($line.PadLeft(([console]::WindowWidth + $line.Length)/2)) -ForegroundColor Magenta
        }

        # Men√ºoptionen
        $opts = @(
            '1) Performance-Men√º',
            '2) Netzwerk-Men√º',
            '3) Software-Update',
            '4) Windows-Tools-Men√º',
            '5) Hardware-Info',
            '6) Beenden'
        )
        # Dynamische Breite
        $innerWidth = ($opts | Measure-Object -Property Length -Maximum).Maximum + 4

        # Box zeichnen
        $top    = '‚ïî' + ('‚ïê' * $innerWidth) + '‚ïó'
        $title  = 'Hauptmen√º'
        $titleLine = '‚ïë' + (' ' * (($innerWidth - $title.Length)/2)) + $title + (' ' * (($innerWidth - $title.Length)/2)) + '‚ïë'
        $sep    = '‚ï†' + ('‚ïê' * $innerWidth) + '‚ï£'
        $bottom = '‚ïö' + ('‚ïê' * $innerWidth) + '‚ïù'

        # Ausgabe
        Write-Host ($top.PadLeft(([console]::WindowWidth + $top.Length)/2)) -ForegroundColor Yellow
        Write-Host ($titleLine.PadLeft(([console]::WindowWidth + $titleLine.Length)/2)) -ForegroundColor Cyan
        Write-Host ($sep.PadLeft(([console]::WindowWidth + $sep.Length)/2)) -ForegroundColor Yellow
        foreach ($opt in $opts) {
            $line = '‚ïë  ' + $opt.PadRight($innerWidth - 2) + '‚ïë'
            Write-Host ($line.PadLeft(([console]::WindowWidth + $line.Length)/2)) -ForegroundColor Green
        }
        Write-Host ($bottom.PadLeft(([console]::WindowWidth + $bottom.Length)/2)) -ForegroundColor Yellow

        # Auswahl
        $sel = Read-Host "Wahl (1-6)"
        switch ($sel) {
            '1' { Show-PerformanceMenu }
            '2' { Show-NetworkMenu }
            '3' { Upgrade-Software }
            '4' { Show-WindowsMenu }
            '5' { Show-HardwareInfo }
            '6' { exit }
            default { Write-Host "Ung√ºltige Auswahl!" -ForegroundColor Red; Start-Sleep 1 }
        }
    }
}



$asciiLogo = @"
 _______  _______ _________ _______  _______ _________
(  ____ )(  ____ \\__   __/(  ____ \(  ____ \\__   __/
| (    )|| (    \/   ) (   | (    \/| (    \/   ) (   
| (____)|| |         | |   | (__    | (_____    | |   
|  _____)| |         | |   |  __)   (_____  )   | |   
| (      | |         | |   | (            ) |   | |   
| )      | (____/\   | |   | (____/\/\____) |   | |   
|/       (_______/   )_(   (_______/\_______)   )_(   
                                                      
"@

Show-Menu -asciiLogo $asciiLogo
